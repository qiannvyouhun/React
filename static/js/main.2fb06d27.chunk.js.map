{"version":3,"sources":["ShowTime1.js","ShowTime2.js","Todolist/Todoinput.js","Todolist/Todoing.js","Todolist/Todolist.js","index.js"],"names":["React","Component","ShowTime","Todoinput","handleInput","e","keyCode","console","log","target","value","props","add","handleChange","setState","name","parseInt","bind","state","a","b","c","this","focus","refs","ref","inp","onChange","onKeyDown","type","onClick","Todoing","todo","map","item","idx","key","del","defaultProps","Todolist","addItem","data","delItem","splice","o","obj","JSON","parse","stringify","Object","assign","obj1","keys","forEach","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.2fb06d27.chunk.js","sourcesContent":["import React from 'react';\r\nclass ShowTime extends React.Component{\r\n    //类当中无法用var声明变量，需要用状态的声明\r\n    constructor(){//constructor是生命周期函数\r\n        super();//this必须放在super之后，不写super得不到this\r\n        //如果想在构造器当中拿到参数需要在super()中传参\r\n        this.state={\r\n            time:new Date().toLocaleString(),\r\n            a:100,\r\n            b:200\r\n        }\r\n        //实时显示当前系统时间setState\r\n        setInterval(()=>{\r\n            this.setState({\r\n                time:new Date().toLocaleString()\r\n            })\r\n        },1000)\r\n    }\r\n    shouldComponentUpdate(){\r\n        if(this.state.a>10){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;//由于返回的是false，所以之后的即使更新也不会进行渲染了\r\n        }\r\n    }\r\n    componentDidUpdate(preProps,preState,data){//有三个参数:前一个的属性，前一个的状态\r\n        console.log(preProps,preState);\r\n    }\r\n    getSnapshotBeforeUpdate(){\r\n        console.log(\"getSnapshotBeforeUpdate\");\r\n        //必须有返回值\r\n        return {name:this.state.a}\r\n    }\r\n    render(){//render函授会自动执行，不用调用（生命周期函数）\r\n        var {name,age}=this.props;\r\n        return (\r\n            <React.Fragment>\r\n                {/* 条件渲染 \"大括号里面不能出现关键词比如if，所以用三步运算符代替*/}\r\n                {name.length>5?<div>姓名：{name}</div>:''}\r\n                {name.length>5&&<div>姓名：{name}</div>}\r\n\r\n                <div>{this.state.time}</div>\r\n                <div>姓名：{name}</div>\r\n                {/* <div>年龄：{age}</div> */}\r\n                {/* 循环渲染 */}\r\n                <div>\r\n                    {\r\n                        age.map((item,index)=>{//调用数组的map方法\r\n                            // return <p>{index}>{item}</p>\r\n                            if(index%2===0){\r\n                                return <p key={index}>{item}</p>\r\n                            }\r\n\r\n                        })\r\n                    }\r\n                </div>\r\n            </React.Fragment>\r\n        )\r\n    }\r\n}\r\n//默认导出：只能导出一次，在被引入的时候可以重命名\r\n// export default ShowTime;\r\n\r\n//命名导出：可以导出多个，被引入时命名一致\r\nexport{ShowTime};\r\nexport const num=100;","import React from 'react';\r\nfunction ShowTime(props){\r\n    console.log(props);\r\n    return (\r\n        //加<React.Fragment>的原因就是ruturn里面的东西必须放在一个闭合的标签里面\r\n        //第一行如果改成import React,{Fragment} from 'react';，该处就可以改成<Fragment> \r\n        <React.Fragment>\r\n            <div>{props.name}</div>\r\n            <div>{new Date().toLocaleString()}</div>\r\n        </React.Fragment>\r\n        \r\n    );\r\n}\r\nexport default ShowTime;//导出","import React, { Component } from 'react'\r\nimport { thisExpression } from '@babel/types';\r\n//受控组件：value值被react控制的表单元素\r\n//可以实时获取表单元素的值（表单验证）/写法比较麻烦\r\nexport default class Todoinput extends Component {\r\n    // constructor(){\r\n    //     //如果下面需要绑定this，需要写上这个代码\r\n    //     super();\r\n    //     this.handleInput=this.handleInput.bind(this);\r\n    // }\r\n    // handleInput(e){      \r\n    //     //判断按下的是哪个键？回车键的键值是13\r\n    //     // console.log(e.keyCode);  \r\n    //     if(e.keyCode==13){\r\n    //         //如何获取输入框里面的值？\r\n    //         console.log(e.target.value);//e.target输入的肯定是input，想要获取到输入的值需要获取vaule\r\n\r\n    //         //拿到父组件的属性：\r\n    //         this.props.add();\r\n    //     }\r\n    // }\r\n\r\n\r\n        constructor(){\r\n            super();\r\n            this.handleInput = this.handleInput.bind(this);\r\n            this.state = {\r\n                a:'',\r\n                b:'',\r\n                c:''\r\n            }\r\n\r\n        }\r\n    //用箭头函数写就不会有this的问题\r\n    handleInput=(e)=>{      \r\n        //绑定this，事件处理函数写成箭头函数\r\n        if(e.keyCode==13){\r\n            console.log(e.target.value);\r\n            this.props.add(e.target.value);\r\n        }\r\n    }\r\n    handleChange=(e)=>{\r\n        this.setState({\r\n            [e.target.name]: parseInt(e.target.value===''?0:e.target.value)\r\n            // inputValue:e.target.value\r\n        })\r\n    }//受控组件\r\n    componentDidMount(){//声明周期的函数是在render之后执行的\r\n        console.log(this);\r\n        this.a.focus();//刷新之后自动获取第一个框的焦点\r\n        // this.refs.a.focus();\r\n        console.log(this.refs.a);\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                {/* <input value=\"abc\" onKeyDown={this.handleInput} type=\"text\"></input> */}\r\n                {/* onKeyDown按下回车执行 */}\r\n                {/*将字符串转换成数字parseInt*/}\r\n                <input ref={(inp)=>{this.a=inp}} name=\"a\" onChange={this.handleChange} value={this.state.a} onKeyDown={this.handleInput} type=\"text\"/>\r\n                +\r\n                <input name=\"b\" onChange={this.handleChange} value={this.state.b} onKeyDown={this.handleInput} type=\"text\"/>\r\n                +\r\n                <input name=\"c\" onChange={this.handleChange} value={this.state.c} onKeyDown={this.handleInput} type=\"text\"/>\r\n                =\r\n                <p>{this.state.a+this.state.b+this.state.c}</p>\r\n                {/*非受控组件:一次性获取或者处理表单元素的值*/}\r\n                <input ref={(inp)=>{this.inp=inp}} type=\"text\"></input>\r\n                <button onClick={()=>{console.log(this.inp.value)}}>提交</button>\r\n            </div>\r\n\r\n        )\r\n    }\r\n}\r\n","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types';\r\nexport default class Todoing extends Component {\r\n    // delItem(idx){\r\n    //     console.log(e);\r\n    //     this.props.del(idx);\r\n    // }\r\n    render() {\r\n        var {todo}=this.props;\r\n        return (\r\n            <ul>\r\n                {/* {\r\n                    todo.map((item)=>{\r\n                        return <li>{item}</li>\r\n                    })\r\n                } */}\r\n\r\n                {\r\n                    todo.map((item,idx)=>\r\n                        <li key={idx}>\r\n                            {item}-----<button onClick={(e)=>this.props.del(idx,e)}>删除</button>\r\n                            {/* 如果需要传参的话，需要加入事件处理函数()=>...,不能只在函数后面加小括号 */}\r\n                            {/* idx是下标 */}\r\n                            {/* {item}-----<button onClick={this.delItem.bind(this,idx)}>删除</button> */}\r\n                        </li>               \r\n                    )}     \r\n            </ul>\r\n        )\r\n    }\r\n}\r\nTodoing.propTypes={\r\n    todo:PropTypes.array,\r\n    del:PropTypes.func\r\n}\r\nTodoing.defaultProps={//引入默认值\r\n    todo:[1,2,3,4,5]\r\n}\r\n\r\n","//父组件:需要将子组件引入\r\n//组件名首字母需要大写\r\nimport React, { Component } from 'react'\r\nimport Todoinput from './Todoinput'\r\nimport Todoing from './Todoing'\r\n\r\nexport default class Todolist extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            todo:[1,2,3]\r\n        }\r\n\r\n        //深拷贝、浅拷贝\r\n        //浅拷贝： var obj={a:100};obj存下的是a=100的一块地址，浅拷贝指的是o拷贝下来的还是一块地址，a=100只有一份\r\n        //深拷贝：拷贝下来的是两份a=100\r\n        var obj={a:100};//浅拷贝\r\n        var o=obj;\r\n        o.a=200;\r\n        console.log(obj);//200\r\n\r\n        var obj={a:100};//深拷贝\r\n        var o={...obj};\r\n        o.a=200;\r\n        console.log(obj);//100\r\n        console.log(o);//200\r\n\r\n        var obj={a:100,b:[1,2,3]};//浅拷贝：只拷贝出来一层，b仍然拷贝的是地址\r\n        var o={...obj};\r\n        o.b[0]=200;\r\n        console.log(obj);//b:[200,2,3]\r\n\r\n        var obj={a:100,b:[1,2,3]};\r\n        var o=JSON.parse(JSON.stringify(obj));//深拷贝\r\n        o.b[0]=200;\r\n        console.log(obj);//b:[1,2,3]\r\n\r\n        var obj={a:100,b:[1,2,3]};\r\n        var obj1={c:300};\r\n        var o=Object.assign({},obj.obj1);\r\n        console.log(o===obj);//fasle\r\n\r\n\r\n        //遍历对象：\r\n        Object.keys(obj).forEach((item)=>{\r\n           console.log(item);\r\n           console.log(obj[item]);\r\n       })//通过Object.keys来遍历\r\n    }\r\n    //添加：\r\n    addItem=(data)=>{\r\n        //子组件--->父组件\r\n        // this.state.todo.push(data);\r\n        // console.log(this.state.todo);\r\n        //改变状态就是setState,\r\n        this.setState({\r\n            todo:[...this.state.todo,data]//把新数组赋值给他，而不是对原来的数组进行改变\r\n        })\r\n    }\r\n    //删除：在子组件中调用父组件中的方法进行删除\r\n    delItem=(idx,e)=>{\r\n        //1、不能处理state，通过setstate去改变\r\n        //2、setstate是异步执行，\r\n        this.setState((state,props)=>{\r\n            console.log(state.todo);\r\n            return{\r\n                todo:todo\r\n            }\r\n        })//第一个参数state是前一个值.但是通过todo:this.state.name+=100直接放在setstate里面时，获取到的可能不是上一个值\r\n        console.log(e);\r\n        let todo=[...this.state.todo];\r\n        //删除某一个数据：splice()\r\n        todo.splice(idx,1);//从idx开始删除，删除一个\r\n        this.setState({\r\n            todo:todo//该处是赋值，将分离出去的todo删除完，赋值给之前的todo，因为名字一样，所以直接写todo也行\r\n        },()=>{\r\n            console.log(this.state.todo);//回调函数拿到的值是最新的，\r\n        })\r\n        // console.log(this.state.todo);//由于是异步执行，所以不会变\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Todoinput add={this.addItem}/>\r\n                {/* add是属性名，可以随便定义 */}\r\n                <Todoing del={this.delItem} todo={this.state.todo}/>                          \r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {ShowTime} from \"./ShowTime1\";//默认导入的是js，可以不写.js\nimport ShowTime2 from \"./ShowTime2\";\nimport './index.css';\nimport Todolist from './Todolist/Todolist';\n\n// react技术栈\n// jsx语法\n// var ele = <h1 class=\"tit\">hello <p>react</p></h1>;\n// babel编译，返回一个对象\n// var ele = React.createElement(\n//     'h1',\n//     {id:'tit',class:'title'},\n//     'hello',\n//     React.createElement(\n//         'p',\n//         {id:'t',class:'tit'},\n//         'react')\n// );\n// ReactDOM.render(ele, document.getElementById('root'));\n// 自己封装render函数\nvar obj = {\n    type: 'div',\n    props: {\n        id: 'box',\n        class: 'box',\n        children: [\n            'hello',\n            'react',\n            {\n                type: 'h1',\n                props: {\n                    id: 'tit',\n                    class: 'tit',\n                    children: [\n                        'title',\n                        'react'\n                    ]\n                }\n            }\n        ]\n    }\n}\nfunction render(obj,container){\n    var {type,props} = obj;\n    // 文档碎片\n    var fragment = document.createDocumentFragment();\n\n    var ele = document.createElement(type);\n    for(var item in props){\n        if(item === 'class'){\n            ele.className = props[item]\n        }else if(item === 'children'){\n            for(var i=0;i<props.children.length;i++){\n                // ele.innerHTML += props.children[i];\n                if(typeof props.children[i] === 'object'){\n                    render(props.children[i],ele);\n                }else{\n                    var txt = document.createTextNode(props.children[i]);\n                    ele.appendChild(txt);\n                }\n            }\n        }else{\n            ele[item] = props[item];\n        }\n    }\n    fragment.appendChild(ele);\n    container.appendChild(fragment);\n}\n\n//组件交互\n// 父组件--------->子组件：调用子组件的时候添加属性，子组件通过props拿到传递到的数据\n// var num=[1,2,3,4,5];\n// ReactDOM.render(\n//     <ShowTime age={num} name=\"zhangsan\"/>,\n//     document.getElementById(\"root\")  \n// )\n\n//子组件-------->父组件：\nReactDOM.render(\n        <Todolist/>,\n        document.getElementById('root')\n    )\n\n/***********************************************第二节(2019-10-12) *****************************************************/\n//类定义组件=>ShowTime1.js\n\n// var num=[1,2,3,4,5];\n// ReactDOM.render(\n//     <ShowTime age={num} name=\"zhangsan\"/>,\n//     document.getElementById(\"root\")  \n//     );\n\n\n\n\n//函数声明组件：没有什么功能的时候使用函数式的=>ShowTime2.js\n// ReactDOM.render(\n//     <ShowTime2 age=\"20\" name=\"zhangsan\"/>,\n//     document.getElementById(\"root\")\n    \n//     );//ShowTime该标签代表了return出来的所有标签\n  \n    \n// //显当前系统时间:现在的方法是每隔一秒进行一次渲染\n// function showTime(){\n//     var ele=<div>{new Date().toLocaleString()}</div>;//toLocaleString()是显示一次时间之后就不会更新了\n//     ReactDOM.render(\n//         ele,\n//         document.querySelector('#root')\n//     );\n// }\n// showTime();\n// setInterval(showTime,1000);\n/*****************************************************第二节(2019-10-12)***************************************************************** */\n\n/************************************************第一节(2019-10-9)************************************************************************ */\n// render(obj,document.getElementById('root'));\n//页面渲染过程：\n//请求HTML页面，浏览器HTML解析器解析html文件，生成DOM树\n//link引入css文件、css解析器解析css，生成css对象模型（cssom），cssom和dom树结合生成一个render树，最后浏览器绘制页面\n\n\n// 页面回流（重排reflow）：DOM结构变化、内容变化、大小、位置的变化\n// 页面重绘（repaint）：颜色的变化（背景色、字体颜色、边框颜色）\n//1、先用变量进行dom处理，最后一次渲染\n// console.time('time');\n// var div=document.getElementById('root');\n// var str=\"\";\n// for(var i=0;i<1000;i++){\n//     // document.getElementById('root').innerHTML += '<p>'+i+'</p>';//这个运行的时间太长\n//     str+='<p>'+i+'</p>';\n// }\n// console.timeEnd('time');\n\n\n//2、对于样式的处理(例如加入背景色)=>声明一个类\n// var div=document.getElementById('root');\n//下面这种方式引起太多次回流\n// div.style.width=\"100px\";\n// div.style.height=\"100px\";\n// div.style.background=\"red\";\n\n//改进的代码（写在css中）：\n// .active{\n//     width:100px;s\n//     height:100px;\n//     background:red;\n// }\n// div.className='active';\n\n\n//3、offsetLeft、offsetWidth等都会引起回流（慎用）\n// console.log(div.offsetLeft);//距离浏览器左边的距离\n\n//每隔100msdiv的宽度变大\n// var wid=div.offsetWidth;\n// setInterval(()=>{\n//     //定义了wid就不会每次都引起回流\n//     wid+=1;\n//     div.style.width=wid+1+'px';\n// },100)\n/*****************************************************************第一节*************************************************************** */"],"sourceRoot":""}